[编程范式](https://www.bilibili.com/video/BV11441137jY?p=10)
## 类型
其实各种类型在32位以及64位或者其他得版本中不尽相同
| 类型 | 字节 |
| :-----| ----: |
| Boolean |  | 
| char | 1 byte | 
| int | 2 byte | 
| short | 2 byte | 
| long | 4 byte | 
| long long | 8 byte | 
| float | 4 byte | 
| doulble | 8 byte | 
不同类型在于不同语言在进行解析的时候会根据规定，将相应的字节数一起进行识别解析。需要考虑的是存储相应的需要的字节数。

### 符号扩充
以下示例
```
short c = -1
int i = c      // -1
```
按照以往的逻辑而言呢 ， 在int四字节的扩展之下 ， i 高位字节填充应该为0，但是会影响c的符号位。所以这里实现的是符号位的填充。根据c的符号位为1，则在int i 中高位的2字节中填充为1。

### float 
![二进制表示](../../img/float-1.png)
公式表示
![](../../img/float-2.jpg)
例如 7.0
```
7.0  *  2^1
3.5  *  2^2
1.75 *  2^3
M -> 1.75   E -> 3

int i = 5;
float c = i;    //5
//在进行转化的时候 ， i为5 -> 变为了c中的5.0

int i = 5
float c = *(float *) &i;
//这里的意思是其实i中与c的内存地址都是同一块 ， 里面的二进制表达都是相同的 ， 只是告诉了程序，解析这块内存的规定一个是用int的解析方式 ， 一个是使用float的解析方式。
```
```
malloc 分配地址
int * arr = malloc(40 * sizeof(int))
其实实际上malloc分配得到的地址是多余160字节的 ， 其原因在于头部的4/8字节中会记录该内存块的信息。返回的其实是记录信息之后的头指针。
```

## 内存管理
[原文](https://zhuanlan.zhihu.com/p/152119007)
### 虚拟地址
操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来.
![虚拟内存](../../img/%E5%86%85%E5%AD%98-%E8%99%9A%E6%8B%9F.jpg)
#### 内存分段
![内存分段](../../img/%E5%86%85%E5%AD%98-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5.jpg)
- 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。
- 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。
![段表](../../img/%E5%86%85%E5%AD%98-%E6%AE%B5%E8%A1%A8.jpg)

### C与汇编
![](../../img/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%80%92%E5%BD%92.jpg)
![](../../img/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%80%92%E5%BD%92-1.jpg)

### 进程 线程描述文件
[原文](https://segmentfault.com/a/1190000038488005)


## 高级的死循环
```
//因为在4数组越界重新更新了i的内存 ，导致i=4之后就变为了0
int main(){
    int i;
    int arr[4];
    for(i=0 ;i<=4;i++){
        arr[i] = 0;
    }
}


//汇编中call<foo>函数循环 ， 在save PC中-4 导致持续call foo函数 内存溢出 ， 因为saved PC是4字节
int foo(){
    int arr[4];
    int i;
    for(i=0;i<=4;i++){
        arr-=4
    }
}
```

## 线程间通信

## 函数范式
scheme