---
title: 计算机网络高级软件编程技术
date: 2020-09-21 18:00:51
tags:计算机网络/c
category: 计算机网络/c
---

# 计算机网络高级软件编程技术

本就不太熟悉`C`语言 ， 但是在上了老师讲的课之后学到了很多。

## 实验一

###  利用`windows`自带`API`探测`MAC`地址

```c
#include <winsock2.h>
#include <iphlpapi.h>
#include <tchar.h>
#include <conio.h>
#include <stdio.h>
#pragma comment (lib , "ws2_32.lib")
#pragma comment (lib , "IPHLPAPI.lib")


int main(int argc, char* argv[]) {
    MIB_IPADDRTABLE* pIPAddrTable 
        = (MIB_IPADDRTABLE*)malloc(sizeof(MIB_IPADDRTABLE));
    ULONG dwSize = 0, dwRetval = 0;

    IN_ADDR IpAddr;
    if (GetIpAddrTable(pIPAddrTable, &dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
        free(pIPAddrTable);
        pIPAddrTable = (MIB_IPADDRTABLE*)malloc(dwSize);
    }
    if ((dwRetval = GetIpAddrTable(pIPAddrTable, &dwSize, 0)) == NO_ERROR) {
        //此处选择table[1]是因为在本地的table表中，
        /*
        Interface Index[0]:     1
        IP Address[0]:          127.0.0.1

        Interface Index[1]:     18
        IP Address[1]:          10.20.187.190
        */ //table[0]是127.0.0.1 ， 是一个回环地址，ARP报文首先会检查是否是本机的IP，是的话就直接丢弃
        ULONG ulHostIp = ntohl(pIPAddrTable->table[1].dwAddr);
        //获得主机IP地址和子网掩码
        ULONG ulHostMask = ntohl(pIPAddrTable->table[1].dwMask);
        ULONG max = (~ulHostMask);
        for (int i = 0; i < (int)pIPAddrTable->dwNumEntries; i++) {//枚举本地的ip table
            printf("\n\tInterface Index[%d]:\t%ld\n", i, pIPAddrTable->table[i].dwIndex);
            IpAddr.S_un.S_addr = (u_long)pIPAddrTable->table[i].dwAddr;
            printf("\tIP Address[%d]:     \t%s\n", i, inet_ntoa(IpAddr));
        }
		for (ULONG I = 1; I < (~ulHostMask); I++) {
		    printf("%d--->%d\n", I, max);
		    static ULONG uNo = 0;
		    HRESULT hr;
            IPAddr ipAddr;
		    ULONG pulMac[2];
		    ULONG ulLen;
		    ipAddr = htonl(I + (ulHostIp & ulHostMask));
		    memset(pulMac, 0xff, sizeof(pulMac));
		    ulLen = 6;
		    hr = SendARP(ipAddr, 0, pulMac, &ulLen);  //探测主机MAC地址
		    if (ulLen == 6) {
                printf("if执行");
		        uNo++;
		        PBYTE pbHexMac = (PBYTE)pulMac;
		        unsigned char* strIpAddr = (unsigned char*)(&ipAddr);
		        printf("% d:MAC address %02X:%02X:%02X:%02X:%02X:%02X"
		            "IP Address % d.% d.% d.%d\n",
		            uNo, pbHexMac[0], pbHexMac[1], pbHexMac[2],
		            pbHexMac[3], pbHexMac[4], pbHexMac[5], strIpAddr[0],
		            strIpAddr[1], strIpAddr[2], strIpAddr[3]);
		    }
		}

    }
    else {
        printf("Call to GetIpAddrTable failed.\n");
    }
    printf("OVER!\n");
    free(pIPAddrTable);
    return;
}
```

`GetIpAddrTable(pIPAddrTable, &dwSize, 0)` 最开始设定的`dwSize`是0，那是因为，虽然`OS`知道系统连接`IP`表以及多少，但是我们自己编写程序的时候是不知道的。`GetIpAddrTable`函数执行，就可以得到`IP table` , 得到`IP`的数量 ， 在后面后面重新进行内存的分配。

#### 分配内存

一般在写`C`语言的时候 ， `int char  long`这些申明的内存是在栈中的，但是`malloc`所申请的内存是在堆中的。

栈内存与堆内存的区别

在`windows`中：一个是用户栈，另一个是内核栈 ， 用户栈可以指定其大小，默认是1MB，通过编译指令/stack可改设其他值 。 不同的操作系统中栈内存的默认大小是不同的。在这个时候 ， 如果你申请的`char []` ,太大，栈内存无法为其分配足够的资源 ， 就会报错**栈溢出**

而对于堆内存而言 ， 在计算机中 ， 存储空间分为硬盘和主存(内存) , 而堆内存所描述的就是内存总所剩余的存储空间

在大型游戏 ， 图像处理工具启动比较慢 ， 在启动之初这些程序就会进行执行`malloc`将堆内存进行全部申请 ， 组成自己的内存池。

#### 连接器

一个c程序可能由多个分别编译的部分组成，连接不同部分的叫做连接器(连接编辑器，载入器)。编译器一次只处理一个文件，所以不能检测出多源程序文件的错误。[链接器](https://zhuanlan.zhihu.com/p/151872874)

#### 字节序

##### 什么是字节序

字节序指的是多字节的数据各字节的存储顺序。在几乎所有计算机中，多字节数据被存储为连续的字节序列

例如，一个4字节的int类型变量a , 假设它的每一字节上对应的十进制数是 23 , 24 , 45 , 12 。由下图可以较为清晰的看出来 ， `OS`在进行存储的时候可以选择从高位地址开始存储 ， 还可以从低位位置开始存储。网卡的发送接收数据也有相同的字节序问题 ， 它也可以从高位/地位进行发送。

![](E:\coding\myWebSite\source\_posts\计算机网络高级软件编程技术\字节序.png)

##### 本地序和网络序

本地序（也称主机序）即指前面处理器本身所采用的字节序，因此有的大端序，有的小端序。而网络序，是指网络传输采用的字节序。所幸，网络序是标准化的，即一般统一采用大端序。因此，**发送网络数据之前需要将数据转换为网络序**，从而避免了前面所担心的问题。而C语言也针对整型数据提供了一组接口，htonl、htons用于本地序转网络序，以及ntohl、ntohs用于网络序转本地序。

##### 强制类型转换

示例

```c
unsigned char* strIpAddr = (unsigned char*)(&ipAddr)
```

指针在`C`中就是一个地址(一个32位的无符号整数),

 <img src="E:\coding\myWebSite\source\_posts\计算机网络高级软件编程技术\强制类型转换.png" style="zoom:50%;" />

指针就是一个地址，不管他前面的类型指定是啥，他都是一个指向一个地址的无符号32位整数。只是它前面的类型规定的是它的访问的类型。比如 `int   /  char`  ， 他们在指针前规定的意义在于

`int` 在`c`语言中是`2/4`字节 ， `char`是`1`字节 ， 所以在根据指针访问的时候，他是根据类型进行几个字节几个字节移动并且读取识别的。



