---
title: 算法
date: 2020-09-05 21:01:56
tags: 算法
category: 算法
---

# `Algorithm`

## 分治法

分治法是一种思想 ， 具体的应用在不用的算法之中。在应用分治法的算法中的基本步骤为

- `Divide`    将一个问题划分为若干个子问题
- `Conquer` 然后一次选择解决子问题
- `Combine` 最后在解决的子问题进行合并

## `Sort`

### 插入排序

插入排序 ，以第二个元素开始 ， 与数组前面的元素依次进行比较 ， 由此插入到适合的位置 ， 而执行到第几个元素的时候 ， 他之前的数组的序列就是有序的。

```javascript
function InsertSort(arr){
    let i = 1     //初始化下标从第二个元素开始
    for(; i < arr.length ; i++ ){
        let j = 0  //每次都从数组的最开始进行比较
        while(arr[i] > arr[j]){
            j++
        }
        let change = arr[i]
        //移动数组元素
        for(let k = i ; k >= j ; k--){
            arr[k] = arr[k-1]
        }
        arr[j] = change
    }
    console.log(arr)
}
```

### 归并排序

`Merge sort` ， 也就是递归排序法 ， 首先他将一个序列分为两份 ， 然后在对分别分为两份的序列进行递归排序，最后在进行合并 ， 重要的地方就在于合并之处 ， 合并的过程为 

- 分别指向两个已经排号的序列的第一个元素 ， 而后进行比较两个元素 ， 谁小谁就放进新的数组里面 ， 然后那个序列在向后移
- 在重复上一个步骤

归并排序的方法也是分治法的应用。

大概的步骤就是 ， 先把一个序列分为两个序列 ， 然后分别对两个序列进行递归分裂，直到每个序列中只有一个一个元素的时候，开始分别从递归树的最下方开始进行两个单独的元素合并上去，最终合并为同一个。

```javascript
function MergeSort(arr){
    const length = arr.length
    //递归退出条件
    if(length === 1){
        return arr
    }

    const halfLength = Math.floor(length/2)
    const left = arr.slice(0 , halfLength) , rigth = arr.slice(halfLength)
    return Merge(MergeSort(left) , MergeSort(rigth))
}

function Merge(left , rigth){
    const res = []
    while(left.length && rigth.length){
        if(left[0] < rigth[0]){
            res.push(left.shift())
        }else{
            res.push(rigth.shift())
        }
    }

    while(left.length){
        res.push(left.shift())
    }
    while(rigth.length){
        res.push(rigth.shift())
    }

    return res
}
```

### 快速排序

快速排序也是利用的分治法的思想 ， 快速排序需要选择一个哨兵(即为划分数组的中间值) ，排序是依据这个哨兵进行排序 。所以这个哨兵值的的大小对于快排的排序的质量就是尤为的重要 ， 关乎着排序的效率。 最好的值就是数组最中间的值 ， 这样一来 ， 所排序执行的递归树是平衡的。而哨兵值过于偏向某一方的时候就会导致递归树的某一分支过来臃肿 ， 从而导致效率的低下。所以哨兵的质量决定了快排的效率。

所以在后面为了让加强改进，就引申出来随机化快速排序，尽量将哨兵的选取进行随机化，以便于递归树尽量的平衡，在对于有序的序列 ， 快排的效率是十分低下的

```javascript
//将数组中的元素对于哨兵的大小进行分边
function Partition(A , p , q){ //A[p ....  q]
    let x = A[p]        //选取哨兵
        , i = p , tag;
    for(let j = p+1 ; j <= q ; j++){
        if(A[j] <= x){
            i++
            let change = A[j]
            A[j] = A[i]
            A[i] = change
        }
    }
    tag = A[p]    
    A[p] = A[i]
    A[i] = tag
    return i
}

function QuickSort(A , p , q){
    if(p < q){
        let r = Partition(A , p , q)
        QuickSort(A , p , r-1)
        QuickSort(A , r+1 , q)
    }
}

const arr = [3, 4, 2 ,6 ,8 ,5]
const q = arr.length
QuickSort(arr , 0 , q)

//随机快排  --- 随机快排的最主要的思想在于选取哨兵是随机的。
function RandomPartition(A , p , q){
    //首先随机选取一个哨兵
    let randomnum = RandomNum(p , q)
    //交换位置
    let x = A[randomnum] , i = p , tag ;
    A[randomnum] = A[p]
    A[p] = x
    for(let j = p+1 ; j <= q ; j++){
        if(A[j] <= x){
            i++
            let change = A[j]
            A[j] = A[i]
            A[i] = change
        }
    }
    tag = A[p]    
    A[p] = A[i]
    A[i] = tag
    return i
}

function RandomQuickSort(A , p , q){
    if(p < q){
        let r = RandomPartition(A , p , q)
        RandomQuickSort(A , p , r-1)
        RandomQuickSort(A , r+1 , q)
    }   
}
```

### 计数排序

计数排序的原理就是，顾名思义，他是需要有计数的。他需要一个缓存数组对输入数组中的元素进行计数的，这也使得缓存数组的大小取决于输入数组中的最大值。虽然比较浪费空间，但是他的排序速度是最快的 ， 因为它是线性的。

这里要注意的一个就是元素的第几个与数组坐标下标匹配问题

```javascript
function CountingSort(A){
    //首先你要找出这个数组的最大值
    let max = 0 , len = A.length , cach = [] , res = []
    for(let i = 0 ; i < len ; i++){
        if(A[i] > max){
            max = A[i]
        }
    }
    //初始化cach数组
    for(i = 0 ; i < max ; i++){
        cach[i] = 0
    }
    //初始化res数组
    for(let i = 0 ; i < len ; i++){
        res[i] = 0
    }
    //对输入数组的元素进行计数
    for(let j = 0 ; j < len ; j++){
        cach[A[j]-1]++
    }
    //对cach数组进行处理 ， 自己的元素值加上前缀
    for(let j = 1 ; j < max ; j++){
        cach[j] += cach[j-1]
    }
    //然后将处理好的cach数组分配到新的数组中
    for(j = len-1 ; j >= 0 ; j--){
        res[cach[A[j]-1]-1] = A[j]
        cach[A[j]-1]--
    }
    return res
}
```

###  基数排序

基数排序用于线性时间处理大范围数据 ， 思想在于换位排序。基本原理在于将一个整数的各个位分出来，分别比较对每位进行比较。每一位都会进行一轮排序 ， 而每一轮都使用的是计数排序。

```javascript
//LSD
function BaseSort(arr , maxDig){
    let res = [] , dev = 1 , mod = 10
    for(let i = 0 ; i < maxDig ; i++ , dev *= 10 , mod *=10){
        for(let j = 0 ; j < arr.length ; j++){
            let buket = parseInt((arr[j] % mod) / dev)   //求取各个位上的数
            if(!res[buket]){                             //计数 ， 
                res[buket] = []
            }
            res[buket].push(arr[j])
        }
        let pos = 0
        for(let j = 0 ; j < res.length ; j++){
            if(res[j]){
                while((value = res[j].shift()) != null){
                    arr[pos++] = value                  //重新覆盖原来的数组，开始下一位的排序
                }
            }
        }
    }
    return arr
} 

let arr = [123 , 234 , 231 , 432 , 32 , 23 , 3]
console.log(BaseSort(arr , 3)) //[3,23,32, 123,231, 234, 432]
```

### 冒泡排序

依次比较相邻的两个元素，比较大小，然后叫最大的数冒泡到最后的位置

```javascript
function swap(arr){
    const len = arr && arr.length
    for(let i = 1 ; i < len ; i++){
        for(let j = 0 ; j < len - i ; j++){
            if(arr[j] > arr[j+1]){
                let change = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = change
            }
        }
    }
}
```

### 选择排序

依次内循环 ， 然后将每次在未排序中的数组里面找到最小的数 ， 记录下`minIndex`,之后在与`i`进行位置互换

```javascript
function selectSort(arr){
    const len = arr.length
    let minIndex ,  min
    for(let i = 0 ; i < len-1 ; i++){
        min = arr[i] , minIndex = i
        for(let j = i ; j < len ; j++){
            if(arr[j] < min){
                //记录
                min = arr[j]
                minIndex = j
            }
        }
        //互换位置
        let change = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = change
    }
}
```

### 希尔排序

```javascript
function shellSort(arr){
    const len = arr.length
    let temp , gap = 1
    while(gap < len/3){
        gap = gap*3+1
    }

    for(gap ; gap > 0 ; gap = Math.floor(gap/3)){
        for(let i = gap ; i < len ; i++){
            temp = arr[i]
            for(let j = i -gap ; j >= 0 && arr[j] > temp ; j-=gap){
                arr[j+gap] = arr[j]
            }
            arr[j+gap] =  temp
        }
    }
}
```

### 堆排序

何为堆：

堆是一种特殊的树结构，它满足下面两种特征：

- 一棵完全二叉树
  - 何为满二叉树
  - <img src="E:\coding\myWebSite\source\_posts\算法\满二叉树.png" style="zoom:50%;" />
  - 何为完全二叉树
  - <img src="E:\coding\myWebSite\source\_posts\算法\完全二叉树.png" style="zoom:50%;" />
- 其中某个节点的值总是不大于/小于其父元素的值

堆是用数组对完全二叉树进行存储的

<img src="E:\coding\myWebSite\source\_posts\算法\堆的二叉树.png" style="zoom:50%;" />

![](E:\coding\myWebSite\source\_posts\算法\堆的数组.png)

为什么在数组的初始位置并没有进行元素的存储 ，而是在数组[1]的地方进行数组的存储。

这是因为方便于找到他们所对应的父元素 ， 例如8所对应的下标为5 , 5/2 = 2 , 即为8所对应的父节点5的位置，这也是后面为了方便我们进行堆化

堆排序的过程就是建立堆的过程,

堆的建立：

<img src="E:\coding\myWebSite\source\_posts\算法\建堆.png" style="zoom:50%;" />

- 第一步 ， 首先数组的第一个元素是6 , 只有一个不需要比较，
- 第二步，数组中的元素为8,比6大，不需要交换
- 第三步，3比6小，需要交换 ， 
- 第四步 ， .....
- ........

```javascript
function swap(arr , i , j){
    const change  = arr[i]
    arr[i] = arr[j]
    arr[j] = change
}

function heapMimx(arr, i){
    if(i <= 0){
        return 
    }
    let half = Math.floor(i/2)
    if(arr[i] < arr[half]){
        swap(arr , half , i)
        heapMimx(arr , half)
    }
}

function heapCreat(arr , j){
    for(let i = 0 ; i < j ; i++){
        heapMimx(arr , i)
    }
}

function heapSort(arr){
    const size = arr.length
    for(let i = size-1 ; i >= 0 ; i--){
        heapCreat(arr , i+1)
        let change = arr[i]
        arr[i] = arr[0]
        arr[0] = change
    }
}
```

堆排序的思想就是利用大根堆或小根堆的性质 ，对数组的元素进行进行堆的构建 ， 根据性质 ， 堆的根节点一定是最大或者是最小的数 ， 然后对`arr[0]`和`arr[length-1]`进行互换 ， 互换之后从最后的元素就有序了 ， 然后就有从前面的元素中利用堆的创建找到最大值或者最小值进行排序

### 桶排序

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：

- 在额外空间充足的情况下，尽量增大桶的数量
- 使用的映射函数能够将输入的 `N `个数据均匀的分配到` K `个桶中

示意图:

![](E:\coding\myWebSite\source\_posts\算法\桶排序.png)

桶排序的步骤：

- 首先在数组中找出元素的最大值与最小值
- 再根据桶的大小分配出桶的个数，并将桶初始化
- 其次再把相应的元素装入到相应的桶中
- 在对桶中的元素进行排序 ， 
- 最后将桶中的排好序的元素进行合并

```javascript
function bucketSort(arr , bucketSize){
    let min = 0 , max = 0 , size = arr.length , res = []
    for(let i = 0 ; i < length ; i++){
        if(arr[i] < min){
            min = arr[i]
        }
        if(arr[i] > max){
            max = arr[i]
        }
    }

    const BUCKET_SIZE = 5
    const bucket = []
    const realSize = bucketSize || BUCKET_SIZE
    for(let i = 0 ; i < Math.floor((max-min)/realSize)+1; i++){
        bucket[i] = []
    }

    //将相应的元素分配到相应的桶中
    for(let i = 0 ; i < size ; i++){
        bucket[Math.floor((arr[i]-min)/realSize)].push(arr[i])
    }
    //对每个桶进行排序
    for(let i = 0 ; i < bucket.length ; i++){
        sort(bucket[i])
        res.push(...bucket[i])     //合并
    }
}
```



## `Search`

### 随机选择

随机选择就是根据传入的`i`值 ， 查找第`i`大的元素 , 利用随机快排的思想进行查找

```javascript
function RandomSelect(A , p , q , i){
    if(p === q) return A[p]
    let r = RandomPartition(A , p , q)
    let k = r - p + 1   //第k大的元素
    if(i === k) return A[r]
    if (i < k) return RandomSelect(A , p , r-1 , i)
    else return RandomSelect(A , r , q , i-k+1)    
}
```

### 二分查找

二分查找是基于有序的序列的情况下，进行查找的一种方式。算法的思想就是，在有序序列中(假设为升序) ，一个元素左边的数肯定是`<=` 它的，而他右边的数肯定是`>=`它的。就这样一直找，知道找到或者就是知道边缘结束

#### 递归

```javascript
function BinarySearch(arr , low , height, target){
    if(low >= height) return 
    const min = low + Math.floor((height-low)/2)
    if(arr[min] === target){
        return arr[min]
    }else if(target < arr[min]){
        BinarySearch(arr , low , min-1  , target)
    }else{
        BinarySearch(arr , min+1 , height , target)
    }
}
```

#### 非递归

```javascript
function BinarySearch(arr , target){
    const size = arr.length
    let low = 0 , height = size - 1 , min
    while(low < height){
        min = low + Math.floor((height-low)/2)
        if(target < arr[min]){
            height = min - 1
        }else{
            low = min + 1
        }
    }
    return arr[low] === target ? arr[low] : null
}
```

## 回溯法详解

回溯法的基本的流程:

```javascript
res = []
backtrack(路径, 选择列表):
    if 满足结束条件
        result.add(路径)
        return
    
    for 选择 in 选择列表
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

### 例题一：全排列

所谓全排列，就是打印出字符串中所有字符的所有排列。例如输入字符串`abc`，则打印出 a、b、c 所能排列出来的所有字符串 `abc`、`acb`、`bac`、`bca`、`cab` 和 `cba` 。

#### 暴力算法

顾名思义，暴力算法就是直接进行，以上述字符串为例 

- 先循环数组 ， 以`a`为一个元素 ， 再去循环数组 ， 但是一个个元素已经是`a` ， 不可行 ， 但是 ， `b` , `c`可行
- 然后在这样一次循环下去

#### 回溯算法

递归算法，就是利用排列组合就是与自己后面的元素进行交换位置，从而达到了实现了排列组合的效果

```javascript
function swap(arr , i , j){
    const change  = arr[i]
    arr[i] = arr[j]
    arr[j] = change
}

function allRange(arr , start , len){
    if(start === len-1){
        console.log(...arr)
        return
    }else{
        //核心for循环
        for(let i = start ; i < len ; i++){
            swap(arr , i , start)       //选择
            allRange(arr , start+1 , len)
            swap(arr , i , start)        //撤销选择
        } 
    }
}

function Permutation(str){
    if(!str) return
    const arr = Array.from(str)
    const size = arr.length
    allRange(arr , 0  , size)
}

Permutation('abcd')
```

<img src="E:\coding\myWebSite\source\_posts\算法\全排序.jpg" style="zoom: 25%;" />

上图中就是全排序算法的流程的具体分析 ， 也可以十分清晰的看到可以程序的走向 ， 这种方法也叫做回溯法，可以看到 ， 当程序走到底部的时候 ， 在重新回到上面的时候，他的状态依旧是会回到最初的状态的。

**关于去重的全排序 **

即`abb` , 因为在当前的元素中就是有重复的元素 ， 所以在回溯法中有特别的地方需要处理 ， 

就是每一个元素最开始都是靠`start` , `for`循环然后去和后面的元素进行位置交换  ，以此进行排列组合。就是每个不同元素在移动它不断地和其他的元素进行交换位置 ， 以此来进行不同的排列组合 ， 但是现在数组中有相同的元素出现， 所以与它相同的元素的位置就已经被它占过了，所以就无需在进行交换 ， 排列不同了。

```javascript
function swap(arr , i , j){
    const change  = arr[i]
    arr[i] = arr[j]
    arr[j] = change
}

function IsSwap(arr , start , end){
    for(let i = start ; i < end ; i++){
        if(arr[end] == arr[i]){
            return false
        }
    }
    return true
}

function allRange2(arr , start , len){
    if(start === len-1){
        console.log(...arr)
        return
    }else{
        for (let i = start; i < len; i++) {
            if (IsSwap(arr, start, i)) {
                swap(arr, i, start)
                allRange2(arr, start + 1, len)
                swap(arr, i, start)
            }
        }
    }
}

function Permutation(str){
    if(!str) return
    const arr = Array.from(str)
    arr.sort()
    const size = arr.length
    allRange2(arr , 0  , size)
}
```

#### 字典序算法

首先先介绍字典序法 

字典序，就是将元素按照字典的顺序（a-z, 1-9）进行排列。以字典的顺序作为比较的依据，可以比较出两个串的大小。比如 "1" < "13"<"14"<"153"， 就是按每个数字位逐个比较的结果。对于一个串“123456789”， 可以知道最小的串是“123456789”，而最大的串“987654321”。这样针对这个串以字典序法生成全排列生成全排列，就是依次生成“123456789”->“123456798”->......->"987654312"->"987654321"这样的串。字典序法要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上

​                                                                                                                                               ------ 来自维基百科

```javascript
//字典序算法
//首先要有根据一个序列生成下一个字典
/**
 * 生成的算法是
 * 首先从序列的最右端开始，依次向左移动 ， 找到第一个左边小于右边的数，记录left
 *在left右边的数字中找到所有比left索引下的数字大的中最下的一个数字记为right
 * 然后交换left 与 right
 * 再将left后面的数字进行有序化(升序)
 */
 function dictionaryCreate(arr){
     const size = arr.length
     let left , right , i = size-1
     while(arr[i-1] >= arr[i]){
         i--
     }
     left = arr[i-1]    //找到left
     i = size-1
     //找right
     while(i > left){
         if(arr[i]>arr[left]){
             if(!right || (right[i] < right[right])){
                right = i
             }
         }
         i--
     }
     swap(arr , left , right)
     const font = arr.slice(0 , left)
     const beyond = arr.slice(left+1 , size-1)
     const newBeyond = Partition(beyond , 0)
     return [...font , ...newBeyond]
 }
```

### 例题二：`N`皇后问题

*`n`* 皇后问题研究的是如何将 `n`个皇后放置在 `n×n `的棋盘上，并且使皇后彼此之间不能相互攻击

给定一个整数` n`，返回所有不同的 `n `皇后问题的解决方案。

每一种解法包含一个明确的` n` 皇后问题的棋子放置方案，该方案中 `'Q' `和 `'.' `分别代表了皇后和空位。

PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。

![](E:\coding\myWebSite\source\_posts\算法\8-queens.png)

```javascript
const res = []
function backtrack(arr , row){
    //当row走到尽头
    if(row === arr.length) {
        res.push(JSON.parse(JSON.stringify(arr)))
        return 
    }
    for(let colum = 0 ; colum < arr.length ; colum++){
        if(!isViad(arr , colum , row)) continue
        swap(arr , row , colum , 'Q')
        backtrack(arr , row+1)
        swap(arr , row , colum , '.')
    }
    
}

function isViad(arr , colum , row){
    //主要检查斜上斜下四个角上的元素
    //检查同一列是否有重复的元素
    let size = arr.length
    for(let i = 0 ; i < size ; i++){
        if(arr[i][colum] === 'Q') return false
    }
    //检查右上角
    if(row>0 && colum < size-1){
        for(let i = row-1 , j = colum+1 ; i >= 0 && j < size ; i-- , j++){
            if(arr[i][j] === 'Q') return false
        }
    }
    //检查左上角
    if(row>0 && colum>0 ){
        for(let i = row-1 , j=colum-1 ; i>= 0 && j>= 0;i-- , j--){
            if(arr[i][j] === 'Q') return false
        }
    }
    return true
}
//放置queen
function swap(arr , i , j, tag){
    arr[i][j] = tag
}

function solveQueens(n){
    //首先初始化一个N*N的二维数组
    const arr = [] 
    for(let i = 0 ; i < n ; i++){
        arr[i] = []
        for(let j = 0; j < n ; j++){
            arr[i][j] = '.'
        }
    }
    res.push(backtrack(arr,0))
    console.log(res)
}
```

### 列题三：矩阵中的路径

**题目描述：**
判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

例如下面的矩阵包含了一条 bfce 路径

<img src="E:\coding\myWebSite\source\_posts\算法\矩阵中的路径.png" style="zoom:50%;" />

解题思路：

这道题也可以使用的方法就是回溯法 , 在一个元素的四个方向上去寻找匹配 ，四个方向中选择一个方向进行移动 ， 并进行标记，以免重复进行。如果在下一步无法进行匹配的时候，就要进行回溯到上一个状态进行另外的一种选择。

```javascript
function sloution(arr , str) {
    const row = arr[0].length , cloum = arr.length , strLength = str.length

    function dfs(i , j , k) {
        //不符合情况的判定
        if(i<0 || i>=cloum || j<0 || j>=row || arr[i][j] !=str[k]) return false
        if(k >= strLength-1) return true     //字符串匹配成功
        const tmp = arr[i][j]              //回溯保存现场
        arr[i][j]  = '-'                   //上锁
        const res = dfs(i-1 , j , k+1) || dfs(i+1 , j , k+1) ||  dfs(i ,j-1 , k+1) || dfs(i,j+1,k+1)
        arr[i][j] = tmp
        return res
    }
    for( let i = 0; i < cloum ; i++){
        for( let j = 0; j < row ; j++){
            if(dfs(i , j , 0)) return true
        }
    }
    return false
}
```

### 例题四：机器人的运动范围

机器人的运动范围就是上下左右的四个方向的不同的范围方向的选择 ，`dfs`暴力遍历即可。但是在这里犯了一个错误,见下注释

```javascript
let count = 0
function robotToMove(m ,n , k){
    // m为列的数量 ，  n为行的数量 ， 
    const initArr = []
    for(let i = 0 ; i < n ;i++){
        initArr[i] = []
        for(let j = 0; j<m ; j++){
            initArr[i][j] = 0
        }
    }

    dfs(initArr , 0 , 0 , m , n , k)
    console.log(count)
}

function dfs( arr,i , j , m ,n , k ){
    //i => m ， j => n
    if(i<0 || j<0 || i>= m || j >=n  || arr[i][j] != 0) return false
    arr[i][j] = 1
    if((numToDiv(i)+numToDiv(j))>k) return false
    count++
    //因为本生就是从0,0开始进行dfs的 ， 所以这里没有必要在进行左边和上方的dfs.因为他们最开始就是从上面进行遍历过来的。如果在加一个dfs(arr , i-1 , j , m , n , k) || dfs(arr , i , j-1 , k)导致了很多没有必要的重复的遍历
    dfs(arr , i+1 , j , m , n , k) || dfs(arr , i , j+1 , m , n , k) 
}

function numToDiv(num){
    //将每个数字的每一位分离出来
    let sum = 0
    const numString = num.toString()
    for(let i = 0 ; i < numString.length ; i++){
        sum += Number(numString[i])
    }
    return sum
}
```



## 动态规划

（英语：Dynamic programming，简称DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的。

​                                                                                                                                                   ——源自维基百科

### 特征

- 问题的一个最优解包含了子问题的最优解
- 重叠子问题：一个递归包含了`"small" number`独立的子问题被反复计算的问题

### 探究过程

以斐波那契数列为列子

#### 第一过程(递归)

最容易想到的就是利用递归的思想，在最开始接触的时候也正是递归的方法

```javascript
function fib(N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

![](E:\coding\myWebSite\source\_posts\算法\动态(递归).jpg)

在上图中可以发现递归树中有许多的计算重复的，因此浪费了许多的空间。

#### 第二个过程(备忘录法)

上面的递归方法中重复了许多的计算，因此我们可以将每一步计算的指存入到数组中，从而避免的重复计算而产生的不必要的开销。
与上述递归代码类似

```javascript
function fib(N) {
    if(!arr[N]){
        if(N == 1 || N == 2) return 1
        arr[N] = fib(N - 1) + fib(N - 2)
    }
    return arr[N]
}
```

这样就减少了递归执行的调用

![](E:\coding\myWebSite\source\_posts\算法\备忘录法.jpg)

所以时间复杂度变为了`O(N)`,这种算法又称为自顶向下

#### 第三个过程(动态规划)

动态规划是经过备忘录的演变，与之不用的是这是自底向上

![](E:\coding\myWebSite\source\_posts\算法\动态规划.jpg)

```javascript
function fib(N) {
    arr[0] = 0
    arr[1] = arr[2] = 1    //初始化
    for(let i = 3 ; i <= N ; i++){
        arr[i] = arr[i-1] + arr[i-2]
    }
    return arr[N]
}

function fib(N) {
    let pre_0 = 0,
        pre_1 = 1,
        next;
    switch(N){
        case 1:
            return pre_1
            break
        default:
            if(N <= 0) return
            for(let i = 2 ; i <= N ; i++){
                next = pre_0 + pre_1
                pre_0 = pre_1
                pre_1 = next 
            }
            return pre_1
    }

}
```

这样一来，我们发现计算的数只是与前两个数的状态有关，所以只需要将前两个的结果保存下来即可。所以这样在空间复杂度上面就有了极大的提升。

### 例题

#### 爬楼梯

描述：

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1**

```javascript
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```javascript
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

分析：

由题意得：

一次只能跳一个或者两格，所以对于初始化：对于一阶楼梯就只有一种方法。而对于两个楼梯而言，上述示例1中。

当时对于三阶而言，对于第一下，假如跳1 ， 剩下2 ， 就是上面初始化中的二阶楼梯跳法

 假如跳2 ， 剩下1 ， 就是上面初始化中的一阶楼梯跳法

 对于四阶而言， 第一下，假如跳1 ， 剩下3 ， 就是上面的三阶楼梯跳法。

 加入跳2 ， 剩下2 ， 就是初始化的二阶楼梯跳法。

所以，综上所述：第`i`阶的方法数 = `i-1`的方法数 + `i-2`的方法数

```javascript
const jump = (n)=>{
    let jump_1 = 1,
        jump_2 = 2,
        sum;
    switch(n){
        case 1:
            return jump_1
            break
        case 2:
            return jump_2
            break
        default:
            if(n < 1) return
            for(let i = 3 ; i <= n ; i++){
                sum = jump_1 + jump_2
                jump_1 = jump_2
                jump_2 = sum
            }        
    }
    return jump_2
}
```



## 常见算法例题

### 最大公约数问题

#### 辗转相除法(欧几里德算法)

两个数q，p
第一步：如果q==0，最大公约数为p；如果p==0，最大公约数为q
第二步：q对p取余，余数赋值给r，将p赋值给q，r赋值给p
(第二步的结果一定满足q大于p)
第三步：回到第一步

```javascript
//辗转相除法
function gcd(a , b){
    if(a === 0 ) return b
    let r = b % a
    b = a
    a = r
    gcd(a , b)
}

function gcd (a, b) {
  return a % b === 0 ? b : gcd(b, a % b)
}
```

#### 更相减损法

第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。
第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止，获取差，即为等数。
则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。

```javascript
function mpd(a , b){
    let i = 0
    if(a%2 === 0 && b%2 === 0){
        while((a= a/2)%2 !=0 || (b= b/2)%2){
            i++
        }
    }
    let s = Subtract(a , b)
    return Math.pow(2 , i)*s
}

function Subtract(a , b){
    let min = a>b ? b : a
    let s = a>b ? a-b : b-a
    if(s === min) return s
    Subtract(s ,min)
}
```

### `KSum`问题

#### `2Sum`问题

- 从首尾搜索两个数的和，并逐步逼近

  - ```javascript
    function Sum2Sort(arr , target){
        //先对数组进行排序
        const q = arr.length
        RandomQuickSort(arr , 0 , q-1)
        const res = []
        //分别用两个指针指向序列的开头与结尾
        let left = 0 , rigth = q-1
        while(left < rigth){
            if(arr[left] + arr[rigth] === target){
                res.push([arr[left] , arr[rigth]])
                left++
                rigth--
            }else if(arr[left] + arr[rigth] < target){
                left++
            }else{
                rigth--
            }
        }
        return res
    }
    ```

- 固定一个数`A`，看`SUM-A`否在这个数组之中

  -  ```javascript
    function Sum2Map(arr , target){
        const map = new Map() , 
        size = arr.length ,
        res = [] ;
        for(let i = 0 ; i < size ; i++){
            map.set(`${arr[i]}` , i)
        }
        for(let j = 0 ; j < size ; j++){
            const lop = arr[j] , other = target - lop
            if(map.get(`${other}`) && map.get(`${other}`)!=j){
                res.push(j , map.get(`${other}`))
                break
            }
        }
        return res
    }
    ```

- 两层`for`循环

  - ```javascript
    function Sum2For(arr , target){
        const size = arr.length
        let res = []
        for(let i = 0 ; i < size ; i++){
            for(let j = i+1 ; j < size ; j++){
                if(arr[i] + arr[j] === target){
                    res.push([arr[i] , arr[j]])
                }
            }
        }
        return res
    }
    ```

#### `3Sum`问题

`3Sum`问题与`4Sum`问题是类似的，上面`2Sum`方法中的前两种方法都是适用的，只是对于`for`嵌套三层而言，对于时间复杂度而言确实是一种极大的考验。

```javascript
function Sum2ToSum3(arr , target , i){
    let left = 0 , rigth = arr.length-1
    while(left < rigth){
        if(left != i && rigth != i){
            if(arr[left] + arr[rigth] === target){
                return [left , rigth]
            }else if(arr[left] + arr[rigth] < target){
                left++
            }else{
                rigth--
            }
        }else if(left === i){
            left++
        }else{
            rigth--
        }
    }    
    return undefined
}

function Sum3Sort(arr, target){
    const size = arr.length
    //先排序
    RandomQuickSort(arr , 0 , size-1)
    if(size < 3) return 
    for(let i = 0 ; i < size ; i++){
        const sum2Target = target - arr[i]
        let res = Sum2ToSum3(arr , sum2Target , i)
        if(res){
            return [i, ...res]
        }
    }
}
```

后面的对于`4Sum   KSum`的问题就是同样的解法，可以分为多个子问题 ， 例如`4Sum`算法，可以先固定一个数 ， 然后再去求解`3Sum`.......

## 剑指`offer`

### 字符串的排列

题目描述：输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。

这个问题就是上述常见算法中的全排列的问题 



### 二维数组中的查找

题目描述：给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

解题思路：因为每一行从左到右递增排序，从上到下也是递增排序。所以对于二维数组其中的一个元素而言，比它小的元素一定在它的左边，比它大的元素一定在它的下边。

![](E:\coding\myWebSite\source\_posts\算法\二维数组查找.gif)

```javascript
function Search(arr , target){
    const row = arr.length
    const column = arr[0].length

    let subRow = 0 , subColum = column-1
    while(subRow < row-1 && subColum > 0){
        if(arr[subRow][subColum] === target){
            return true
        }else if(target < arr[subRow][subColum]){
            subColum--
        }else{
            subRow++
        }
    }
    return false
}

```

### 重构二叉树

首先先来复习一下树的前序遍历 ，中序遍历 ， 以及后序遍历

#### 前序遍历

![](E:\coding\myWebSite\source\_posts\算法\前序遍历.jpg)

#### 中序遍历

![](E:\coding\myWebSite\source\_posts\算法\中序遍历.jpg)

#### 后序遍历

![](E:\coding\myWebSite\source\_posts\算法\后序遍历.jpg)

题目描述：根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

解题思路：
前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

- 首先由前序遍历的第一个元素确定数的根元素
- 然后由中序遍历的结果根据上述得到的根元素判断根元素的左子树和右子树
- 然后可以在前序结果中将左右子树分开
- 在左右子树中递归第1,2,3步直到节点为空

<img src="E:\coding\myWebSite\source\_posts\算法\重建二叉树.png" style="zoom:50%;" />

<img src="E:\coding\myWebSite\source\_posts\算法\前序遍历.gif" style="zoom:50%;" />

```javascript
class TreeNode{
    constructor(value){
        this.value = value
        this.left = null
        this.right = null
    }

    addLeftChild(value){
        this.left = value
    }
    addRightChild(value){
        this.right = value
    }
}


function prologueToTree(preorder , inorder){
    if(preorder.length === 0 || inorder.length === 0){
        return null
    }
    //root为前序遍历的第一个元素
    const node = new TreeNode(preorder[0])
    //找到对应的中序遍历中的root的index
    let index = inorder.indexOf(preorder[0])
    //根据中序遍历的结果确定左右子树的范围
    let inLeftTree = inorder.slice(0,index)
    let inRightTree = inorder.slice(index+1)

    //根据前序遍历拿到相应的左右子树的范围
    let perLeftTree = preorder.slice(1 , index+1)
    let preRightTree = preorder.slice(index+1)

    node.addLeftChild(prologueToTree(perLeftTree , inLeftTree))
    node.addRightChild(prologueToTree(preRightTree , inRightTree))

    return node

}
```

### 数组中数字出现的次数

#### 热身

一个整型数组 `nums` 里除一个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是`O(n)`，空间复杂度是`O(1)`。

解题思路 ： 

此题的难点在于空间复杂度为`O(1)` , 所有并不能申明太多的变量 ， 但是还是可以使用`for`循环的 ， 因为此处的时间复杂度为`O(n)`。此题的解法就是使用异或方法。

异或:

![](E:\coding\myWebSite\source\_posts\算法\异或.png)

- 性质 : 
  - 相同的数字异或 = 0
  - `a^b^c = a^c^b`
  - `a^b^c^d = (a^b)^(c^d)`

所以对于上面的问题就是十分的简单了，将数组中的所有元素进行异或 ， 得到数字就是那个单独出现的数字

```javascript
function oneAlone(arr){
    let res = 0 , size = arr.length
    for(let i = 0 ; i<size ; i++){
        res ^= arr[i]
    }
    return res
}
```

#### 进阶

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是`O(n)`，空间复杂度是`O(1)`。

解题思路 ： 

如果没有时间复杂度的限制 ， 可以使用两层`for`循环嵌套 ， 有两个指针指向数组中的两个元素，然后将剩下的元素进行异或运算，如果结果等于0的话，那就是这两个数。但是此处的时间复杂度为`O(n)`  ，所以是不能够进行`for`循环的嵌套的。但是仅仅只是执行一次`for`循环的话只能得到的是数组元素的一起异或共同得到的结果 ， 拿得到的结果就是单独出现的两个数的异或的结果。但是我们的最后得到的结果是要将他们分开的。

所以此处解题的关键就是 ， 将一次`for`循环得到的两个单独出现数异或的结果进行检查 ，得到结果在二进制中的第一个为1的位 ， 然后变为一个整数。因为这一位的1代表这两个单数出现的数字的不同，这就是分开两个数字的关键。然后用此为去与运算 ， `for`循环数组中的元素 ， 就将两个数分开了。其他的因为还是进行了两次与相同的数字进行异或，得到的结果是不用影响的。

```javascript
function twoAlone(arr){
    //因为在JavaScript中number类型是双精度 ， 占到64位
    let res = 0 , a = 0 , b = 0 , size = arr.length
    for(let i = 0 ; i < size ; i++){
        res ^= arr[i]              //得到两个数字的异或
    }
    let h = 1
    while(res & h === 0){//找到res中为1的第一位
        h <<= 1
    } 

    for(let i = 0 ; i < size ; i++){
        if(h & arr[i] === 0){
            a ^= arr[i]
        }else{
            b ^= arr[i]
        }
    }
    return [a,b]
}
```

#### 类似题目

除了一个数字出现一次，其他都出现了三次，让我们找到出现一次的数。

此题主要是位运算的灵活应用。

解题思路为 ， 对数组中的元素的每一位二进制进行比较 ， 找出单独出现的元素在1出现的位数的位置。并将它还原出来

```javascript
function oneAloneTreeRe(arr){
    let size = arr.length , res = 0;
    //因为在JavaScript中number类型是双精度,占到64位。但是这里的数都是整数
    for(let i = 0 ; i < 32 ; i++){
        let count = 0 ,
            bit = 1 << i;

        for(let j = 0 ; j <size ; j++){
            if(arr[j]&bit) count++
        }    
        if(count%3 != 0 ) res = res | bit
    }
    return res
}
```

### 两个栈实现队列

首先复习一下栈和队列这两种数据结构

<img src="E:\coding\myWebSite\source\_posts\算法\队与列.jpg" style="zoom:50%;" />

队列的最主要的特征就是先进先出`FIFO`,栈的最主要的特征就是先进后出`LILO`。其实在底层都是一样的，`C/C++`中都是用链表的形式进行实现，这里`JS`用的是数组进行实现的。它的的主要的区别就是通过暴露在外的`API`实现的。

题目描述：用两个栈来实现一个队列，完成队列的 `Push` 和 `Pop `操作。

```javascript
class stack{
    constructor(){
        this.value = []
    }

    push(){
        this.value.push(...arguments)
    }

    pop(){
        return this.value.pop()
    }
}

class Queue{
    constructor(){
        this.s1 = new stack()
        this.s2 = new stack()
    }

    push(){
        this.s1.push(...arguments)
    }
    pop(){
        let s
        while(s = this.s1.pop()){
            this.s2.push(s)
        }
        return this.s2.pop()
    }
}
```

### 两个队列实现栈

```javascript
class Queue{
    constructor(){
        this.value = []
        this.length = 0
    }

    push(){
        this.value.push(...arguments)
        this.length = this.value.length
    }

    pop(){
        let node =  this.value.shift()
        this.length = this.value.length
        return node
    }

}

class Stack{
    constructor(){
        this.arr = new Queue
    }

    push(){
        this.arr.push(...arguments)
    }

    pop(){
        //将队列中的前面的元素，除了最后一个元素push到队列后面
        let size = this.arr.length
        console.log('length:' , size)
        for(let i = 0 ; i < size-1 ; i++){
            this.arr.push(this.arr.pop())
        }
        return this.arr.pop()
    }
}
```



### 矩阵中的路径

**题目描述：**
判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

例如下面的矩阵包含了一条 bfce 路径

<img src="E:\coding\myWebSite\source\_posts\算法\矩阵中的路径.png" style="zoom:50%;" />

解题思路：

这道题也可以使用的方法就是回溯法 , 在一个元素的四个方向上去寻找匹配 ，四个方向中选择一个方向进行移动 ， 并进行标记，以免重复进行。如果在下一步无法进行匹配的时候，就要进行回溯到上一个状态进行另外的一种选择。

```javascript
function sloution(arr , str) {
    const row = arr[0].length , cloum = arr.length , strLength = str.length

    function dfs(i , j , k) {
        //不符合情况的判定
        if(i<0 || i>=cloum || j<0 || j>=row || arr[i][j] !=str[k]) return false
        if(k >= strLength-1) return true     //字符串匹配成功
        const tmp = arr[i][j]              //回溯保存现场
        arr[i][j]  = '-'                   //上锁
        const res = dfs(i-1 , j , k+1) || dfs(i+1 , j , k+1) ||  dfs(i ,j-1 , k+1) || dfs(i,j+1,k+1)
        arr[i][j] = tmp
        return res
    }
    for( let i = 0; i < cloum ; i++){
        for( let j = 0; j < row ; j++){
            if(dfs(i , j , 0)) return true
        }
    }
    return false
}
```





 