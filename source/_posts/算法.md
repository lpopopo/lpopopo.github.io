---
title: 算法
date: 2020-09-05 21:01:56
tags: 算法
category: 算法
---

# `Algorithm`

## 分治法

分治法是一种思想 ， 具体的应用在不用的算法之中。在应用分治法的算法中的基本步骤为

- `Divide`    将一个问题划分为若干个子问题
- `Conquer` 然后一次选择解决子问题
- `Combine` 最后在解决的子问题进行合并

## `Sort`

### 插入排序

插入排序 ，以第二个元素开始 ， 与数组前面的元素依次进行比较 ， 由此插入到适合的位置 ， 而执行到第几个元素的时候 ， 他之前的数组的序列就是有序的。

```javascript
function InsertSort(arr){
    let i = 1     //初始化下标从第二个元素开始
    for(; i < arr.length ; i++ ){
        let j = 0  //每次都从数组的最开始进行比较
        while(arr[i] > arr[j]){
            j++
        }
        let change = arr[i]
        //移动数组元素
        for(let k = i ; k >= j ; k--){
            arr[k] = arr[k-1]
        }
        arr[j] = change
    }
    console.log(arr)
}
```

### 归并排序

`Merge sort` ， 也就是递归排序法 ， 首先他将一个序列分为两份 ， 然后在对分别分为两份的序列进行递归排序，最后在进行合并 ， 重要的地方就在于合并之处 ， 合并的过程为 

- 分别指向两个已经排号的序列的第一个元素 ， 而后进行比较两个元素 ， 谁小谁就放进新的数组里面 ， 然后那个序列在向后移
- 在重复上一个步骤

归并排序的方法也是分治法的应用。

大概的步骤就是 ， 先把一个序列分为两个序列 ， 然后分别对两个序列进行递归分裂，直到每个序列中只有一个一个元素的时候，开始分别从递归树的最下方开始进行两个单独的元素合并上去，最终合并为同一个。

```javascript
function MergeSort(arr){
    const length = arr.length
    //递归退出条件
    if(length === 1){
        return arr
    }

    const halfLength = Math.floor(length/2)
    const left = arr.slice(0 , halfLength) , rigth = arr.slice(halfLength)
    return Merge(MergeSort(left) , MergeSort(rigth))
}

function Merge(left , rigth){
    const res = []
    while(left.length && rigth.length){
        if(left[0] < rigth[0]){
            res.push(left.shift())
        }else{
            res.push(rigth.shift())
        }
    }

    while(left.length){
        res.push(left.shift())
    }
    while(rigth.length){
        res.push(rigth.shift())
    }

    return res
}
```

### 快速排序

快速排序也是利用的分治法的思想 ， 快速排序需要选择一个哨兵(即为划分数组的中间值) ，排序是依据这个哨兵进行排序 。所以这个哨兵值的的大小对于快排的排序的质量就是尤为的重要 ， 关乎着排序的效率。 最好的值就是数组最中间的值 ， 这样一来 ， 所排序执行的递归树是平衡的。而哨兵值过于偏向某一方的时候就会导致递归树的某一分支过来臃肿 ， 从而导致效率的低下。所以哨兵的质量决定了快排的效率。

所以在后面为了让加强改进，就引申出来随机化快速排序，尽量将哨兵的选取进行随机化，以便于递归树尽量的平衡，在对于有序的序列 ， 快排的效率是十分低下的

```javascript
//将数组中的元素对于哨兵的大小进行分边
function Partition(A , p , q){ //A[p ....  q]
    let x = A[p]        //选取哨兵
        , i = p , tag;
    for(let j = p+1 ; j <= q ; j++){
        if(A[j] <= x){
            i++
            let change = A[j]
            A[j] = A[i]
            A[i] = change
        }
    }
    tag = A[p]    
    A[p] = A[i]
    A[i] = tag
    return i
}

function QuickSort(A , p , q){
    if(p < q){
        let r = Partition(A , p , q)
        QuickSort(A , p , r-1)
        QuickSort(A , r+1 , q)
    }
}

const arr = [3, 4, 2 ,6 ,8 ,5]
const q = arr.length
QuickSort(arr , 0 , q)

//随机快排  --- 随机快排的最主要的思想在于选取哨兵是随机的。
function RandomPartition(A , p , q){
    //首先随机选取一个哨兵
    let randomnum = RandomNum(p , q)
    //交换位置
    let x = A[randomnum] , i = p , tag ;
    A[randomnum] = A[p]
    A[p] = x
    for(let j = p+1 ; j <= q ; j++){
        if(A[j] <= x){
            i++
            let change = A[j]
            A[j] = A[i]
            A[i] = change
        }
    }
    tag = A[p]    
    A[p] = A[i]
    A[i] = tag
    return i
}

function RandomQuickSort(A , p , q){
    if(p < q){
        let r = RandomPartition(A , p , q)
        RandomQuickSort(A , p , r-1)
        RandomQuickSort(A , r+1 , q)
    }   
}
```

### 计数排序

计数排序的原理就是，顾名思义，他是需要有计数的。他需要一个缓存数组对输入数组中的元素进行计数的，这也使得缓存数组的大小取决于输入数组中的最大值。虽然比较浪费空间，但是他的排序速度是最快的 ， 因为它是线性的。

这里要注意的一个就是元素的第几个与数组坐标下标匹配问题

```javascript
function CountingSort(A){
    //首先你要找出这个数组的最大值
    let max = 0 , len = A.length , cach = [] , res = []
    for(let i = 0 ; i < len ; i++){
        if(A[i] > max){
            max = A[i]
        }
    }
    //初始化cach数组
    for(i = 0 ; i < max ; i++){
        cach[i] = 0
    }
    //初始化res数组
    for(let i = 0 ; i < len ; i++){
        res[i] = 0
    }
    //对输入数组的元素进行计数
    for(let j = 0 ; j < len ; j++){
        cach[A[j]-1]++
    }
    //对cach数组进行处理 ， 自己的元素值加上前缀
    for(let j = 1 ; j < max ; j++){
        cach[j] += cach[j-1]
    }
    //然后将处理好的cach数组分配到新的数组中
    for(j = len-1 ; j >= 0 ; j--){
        res[cach[A[j]-1]-1] = A[j]
        cach[A[j]-1]--
    }
    return res
}
```

###  基数排序

基数排序用于线性时间处理大范围数据 ， 思想在于换位排序。基本原理在于将一个整数的各个位分出来，分别比较对每位进行比较。每一位都会进行一轮排序 ， 而每一轮都使用的是计数排序。

```javascript
//LSD
function BaseSort(arr , maxDig){
    let res = [] , dev = 1 , mod = 10
    for(let i = 0 ; i < maxDig ; i++ , dev *= 10 , mod *=10){
        for(let j = 0 ; j < arr.length ; j++){
            let buket = parseInt((arr[j] % mod) / dev)   //求取各个位上的数
            if(!res[buket]){                             //计数 ， 
                res[buket] = []
            }
            res[buket].push(arr[j])
        }
        let pos = 0
        for(let j = 0 ; j < res.length ; j++){
            if(res[j]){
                while((value = res[j].shift()) != null){
                    arr[pos++] = value                  //重新覆盖原来的数组，开始下一位的排序
                }
            }
        }
    }
    return arr
} 

let arr = [123 , 234 , 231 , 432 , 32 , 23 , 3]
console.log(BaseSort(arr , 3)) //[3,23,32, 123,231, 234, 432]
```

### 冒泡排序

依次比较相邻的两个元素，比较大小，然后叫最大的数冒泡到最后的位置

```javascript
function swap(arr){
    const len = arr && arr.length
    for(let i = 1 ; i < len ; i++){
        for(let j = 0 ; j < len - i ; j++){
            if(arr[j] > arr[j+1]){
                let change = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = change
            }
        }
    }
}
```

### 选择排序

依次内循环 ， 然后将每次在未排序中的数组里面找到最小的数 ， 记录下`minIndex`,之后在与`i`进行位置互换

```javascript
function selectSort(arr){
    const len = arr.length
    let minIndex ,  min
    for(let i = 0 ; i < len-1 ; i++){
        min = arr[i] , minIndex = i
        for(let j = i ; j < len ; j++){
            if(arr[j] < min){
                //记录
                min = arr[j]
                minIndex = j
            }
        }
        //互换位置
        let change = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = change
    }
}
```

### 希尔排序

```javascript
function shellSort(arr){
    const len = arr.length
    let temp , gap = 1
    while(gap < len/3){
        gap = gap*3+1
    }

    for(gap ; gap > 0 ; gap = Math.floor(gap/3)){
        for(let i = gap ; i < len ; i++){
            temp = arr[i]
            for(let j = i -gap ; j >= 0 && arr[j] > temp ; j-=gap){
                arr[j+gap] = arr[j]
            }
            arr[j+gap] =  temp
        }
    }
}
```

### 堆排序

何为堆：

堆是一种特殊的树结构，它满足下面两种特征：

- 一棵完全二叉树
  - 何为满二叉树
  - <img src="E:\coding\myWebSite\source\_posts\算法\满二叉树.png" style="zoom:50%;" />
  - 何为完全二叉树
  - <img src="E:\coding\myWebSite\source\_posts\算法\完全二叉树.png" style="zoom:50%;" />
- 其中某个节点的值总是不大于/小于其父元素的值

堆是用数组对完全二叉树进行存储的

<img src="E:\coding\myWebSite\source\_posts\算法\堆的二叉树.png" style="zoom:50%;" />

![](E:\coding\myWebSite\source\_posts\算法\堆的数组.png)

为什么在数组的初始位置并没有进行元素的存储 ，而是在数组[1]的地方进行数组的存储。

这是因为方便于找到他们所对应的父元素 ， 例如8所对应的下标为5 , 5/2 = 2 , 即为8所对应的父节点5的位置，这也是后面为了方便我们进行堆化

堆排序的过程就是建立堆的过程,

堆的建立：

<img src="E:\coding\myWebSite\source\_posts\算法\建堆.png" style="zoom:50%;" />

- 第一步 ， 首先数组的第一个元素是6 , 只有一个不需要比较，
- 第二步，数组中的元素为8,比6大，不需要交换
- 第三步，3比6小，需要交换 ， 
- 第四步 ， .....
- ........

```javascript
function swap(arr , i , j){
    const change  = arr[i]
    arr[i] = arr[j]
    arr[j] = change
}

function heapMimx(arr, i){
    if(i <= 0){
        return 
    }
    let half = Math.floor(i/2)
    if(arr[i] < arr[half]){
        swap(arr , half , i)
        heapMimx(arr , half)
    }
}

function heapCreat(arr , j){
    for(let i = 0 ; i < j ; i++){
        heapMimx(arr , i)
    }
}

function heapSort(arr){
    const size = arr.length
    for(let i = size-1 ; i >= 0 ; i--){
        heapCreat(arr , i+1)
        let change = arr[i]
        arr[i] = arr[0]
        arr[0] = change
    }
}
```

堆排序的思想就是利用大根堆或小根堆的性质 ，对数组的元素进行进行堆的构建 ， 根据性质 ， 堆的根节点一定是最大或者是最小的数 ， 然后对`arr[0]`和`arr[length-1]`进行互换 ， 互换之后从最后的元素就有序了 ， 然后就有从前面的元素中利用堆的创建找到最大值或者最小值进行排序

### 桶排序

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：

- 在额外空间充足的情况下，尽量增大桶的数量
- 使用的映射函数能够将输入的 `N `个数据均匀的分配到` K `个桶中

示意图:

![](E:\coding\myWebSite\source\_posts\算法\桶排序.png)

桶排序的步骤：

- 首先在数组中找出元素的最大值与最小值
- 再根据桶的大小分配出桶的个数，并将桶初始化
- 其次再把相应的元素装入到相应的桶中
- 在对桶中的元素进行排序 ， 
- 最后将桶中的排好序的元素进行合并

```javascript
function bucketSort(arr , bucketSize){
    let min = 0 , max = 0 , size = arr.length , res = []
    for(let i = 0 ; i < length ; i++){
        if(arr[i] < min){
            min = arr[i]
        }
        if(arr[i] > max){
            max = arr[i]
        }
    }

    const BUCKET_SIZE = 5
    const bucket = []
    const realSize = bucketSize || BUCKET_SIZE
    for(let i = 0 ; i < Math.floor((max-min)/realSize)+1; i++){
        bucket[i] = []
    }

    //将相应的元素分配到相应的桶中
    for(let i = 0 ; i < size ; i++){
        bucket[Math.floor((arr[i]-min)/realSize)].push(arr[i])
    }
    //对每个桶进行排序
    for(let i = 0 ; i < bucket.length ; i++){
        sort(bucket[i])
        res.push(...bucket[i])     //合并
    }
}
```



## `Search`

### 随机选择

随机选择就是根据传入的`i`值 ， 查找第`i`大的元素 , 利用随机快排的思想进行查找

```javascript
function RandomSelect(A , p , q , i){
    if(p === q) return A[p]
    let r = RandomPartition(A , p , q)
    let k = r - p + 1   //第k大的元素
    if(i === k) return A[r]
    if (i < k) return RandomSelect(A , p , r-1 , i)
    else return RandomSelect(A , r , q , i-k+1)    
}
```

## 动态规划

（英语：Dynamic programming，简称DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的。

​                                                                                                                                                   ——源自维基百科

### 特征

- 问题的一个最优解包含了子问题的最优解
- 重叠子问题：一个递归包含了`"small" number`独立的子问题被反复计算的问题

### 探究过程

以斐波那契数列为列子

#### 第一过程(递归)

最容易想到的就是利用递归的思想，在最开始接触的时候也正是递归的方法

```javascript
function fib(N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

![](E:\coding\myWebSite\source\_posts\算法\动态(递归).jpg)

在上图中可以发现递归树中有许多的计算重复的，因此浪费了许多的空间。

#### 第二个过程(备忘录法)

上面的递归方法中重复了许多的计算，因此我们可以将每一步计算的指存入到数组中，从而避免的重复计算而产生的不必要的开销。
与上述递归代码类似

```javascript
function fib(N) {
    if(!arr[N]){
        if(N == 1 || N == 2) return 1
        arr[N] = fib(N - 1) + fib(N - 2)
    }
    return arr[N]
}
```

这样就减少了递归执行的调用

![](E:\coding\myWebSite\source\_posts\算法\备忘录法.jpg)

所以时间复杂度变为了`O(N)`,这种算法又称为自顶向下

#### 第三个过程(动态规划)

动态规划是经过备忘录的演变，与之不用的是这是自底向上

![](E:\coding\myWebSite\source\_posts\算法\动态规划.jpg)

```javascript
function fib(N) {
    arr[0] = 0
    arr[1] = arr[2] = 1    //初始化
    for(let i = 3 ; i <= N ; i++){
        arr[i] = arr[i-1] + arr[i-2]
    }
    return arr[N]
}

function fib(N) {
    let pre_0 = 0,
        pre_1 = 1,
        next;
    switch(N){
        case 1:
            return pre_1
            break
        default:
            if(N <= 0) return
            for(let i = 2 ; i <= N ; i++){
                next = pre_0 + pre_1
                pre_0 = pre_1
                pre_1 = next 
            }
            return pre_1
    }

}
```

这样一来，我们发现计算的数只是与前两个数的状态有关，所以只需要将前两个的结果保存下来即可。所以这样在空间复杂度上面就有了极大的提升。

### 例题

#### 爬楼梯

描述：

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1**

```javascript
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```javascript
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

分析：

由题意得：

一次只能跳一个或者两格，所以对于初始化：对于一阶楼梯就只有一种方法。而对于两个楼梯而言，上述示例1中。

当时对于三阶而言，对于第一下，假如跳1 ， 剩下2 ， 就是上面初始化中的二阶楼梯跳法

 假如跳2 ， 剩下1 ， 就是上面初始化中的一阶楼梯跳法

 对于四阶而言， 第一下，假如跳1 ， 剩下3 ， 就是上面的三阶楼梯跳法。

 加入跳2 ， 剩下2 ， 就是初始化的二阶楼梯跳法。

所以，综上所述：第`i`阶的方法数 = `i-1`的方法数 + `i-2`的方法数

```javascript
const jump = (n)=>{
    let jump_1 = 1,
        jump_2 = 2,
        sum;
    switch(n){
        case 1:
            return jump_1
            break
        case 2:
            return jump_2
            break
        default:
            if(n < 1) return
            for(let i = 3 ; i <= n ; i++){
                sum = jump_1 + jump_2
                jump_1 = jump_2
                jump_2 = sum
            }        
    }
    return jump_2
}
```



## 常见算法例题

